# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020 - 2021, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 安杰 许, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.dev1734+gca660ba1e\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-12 10:06+0000\n"
"PO-Revision-Date: 2021-10-13 01:29+0000\n"
"Last-Translator: 安杰 许, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/TVMChinese/teams/124815/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../_staging/arch/runtime.rst:21
msgid "TVM Runtime System"
msgstr "TVM runtime系统"

#: ../../_staging/arch/runtime.rst:23
msgid ""
"TVM supports multiple programming languages for the compiler stack "
"development and deployment. In this note, we explain the key elements of the"
" TVM runtime."
msgstr "TVM支持多种编程语言用于编译器堆栈的开发和部署。在本文中，我们会解释TVM runtime的关键元素。"

#: ../../_staging/arch/runtime.rst:28
msgid "We need to satisfy quite a few interesting requirements:"
msgstr "我们需要满足许多有趣的要求："

#: ../../_staging/arch/runtime.rst:30
msgid ""
"Deployment: invoke the compiled function from python/javascript/c++ "
"language."
msgstr "部署：用python/javascrip/c++语言调用编译后的函数。"

#: ../../_staging/arch/runtime.rst:31
msgid ""
"Debug: define a function in python and call that from a compiled function."
msgstr "调试：用python定义一个函数并在一个编译后的函数中调用它。"

#: ../../_staging/arch/runtime.rst:32
msgid ""
"Link: write driver code to call device specific code (CUDA) and call it from"
" compiled host function."
msgstr "链接：编写驱动代码来调用设备特定代码（CUDA）并在编译后的主机函数中调用它。"

#: ../../_staging/arch/runtime.rst:33
msgid ""
"Prototype: define an IR pass from python and call that from C++ backend."
msgstr "原型：用python定义一个IR pass然后从C++后端中调用。"

#: ../../_staging/arch/runtime.rst:34
msgid "Expose: compiler stack developed in c++ to front-end (i.e, python)"
msgstr "公开：从用c++开发的编译器堆栈到前端（如python）"

#: ../../_staging/arch/runtime.rst:35
msgid ""
"Experiment: ship a compiled function to an embedded device to directly run "
"there."
msgstr "实验：将编译后的函数发送到嵌入式设备来直接运行。"

#: ../../_staging/arch/runtime.rst:37
msgid ""
"We want to be able to define a function from any language and call from "
"another. We also want the runtime core to be minimal to deploy to embedded "
"devices."
msgstr "我们想要能用任何语言定义一个函数然后用另一个语言来调用它。我们还希望runtime核能小到足以部署在嵌入式设备上。"

#: ../../_staging/arch/runtime.rst:43
msgid "PackedFunc"
msgstr "PackedFunc"

#: ../../_staging/arch/runtime.rst:45
msgid ""
"`PackedFunc`_ is a simple but elegant solution we find to solve the "
"challenges listed.  A single ``PackedFunc`` object represents a function "
"call whose caller and callee may be in different languages."
msgstr ""
"我们发现，`PackedFunc`_是一种简单但优雅的解决方案，可以解决提出的挑战。单个 ``PackedFunc`` "
"对象表示一个函数调用，这个函数的调用方和被调用方可能使用的不同语言。"

#: ../../_staging/arch/runtime.rst:49
msgid "The following code block provides an example in C++"
msgstr "下面代码块提供了一个C++中的例子"

#: ../../_staging/arch/runtime.rst:71
msgid ""
"In the above codeblock, we defined a PackedFunc MyAdd. It takes two "
"arguments : ``args`` represents input arguments and ``rv`` represents return"
" value. The function is type-erased, which means that the function signature"
" does not restrict which input type to pass in or type to return. Under the "
"hood, when we call a PackedFunc, it packs the input arguments to TVMArgs on "
"stack, and gets the result back via TVMRetValue."
msgstr ""
"在上述代码块中，我们定义了一个PackedFunc MyAdd。 它有两个参数： ``args`` 表示输入参数， ``rv`` "
"表示返回值。这个函数被类型擦除，即这个函数签名不限制要传入的输入类型和要返回的类型。在后台，当我们调用一个 "
"PackedFunc,它将输入参数打包到堆栈上的TVMArgs，然后通过TVMRetValue得到返回结果。"

#: ../../_staging/arch/runtime.rst:77
msgid ""
"Thanks to template tricks in C++, we can call a PackedFunc just like a "
"normal function. Because of its type-erased nature, we can call a PackedFunc"
" from dynamic languages like python, without additional glue code for each "
"new type function created. The following example registers PackedFunc in C++"
" and calls from python."
msgstr ""
"多亏于C++中的模板技巧，我们可以像调用一个正常函数一样调用一个 PackedFunc。因为他的类型擦除特性，我们可以从动态语言像python调用一个 "
"PackedFunc，而无需为每一个新类型函数的生成添加额外的粘合代码。下面的示例用C++注册了 PackedFunc然后用python来调用它。"

#: ../../_staging/arch/runtime.rst:94
msgid ""
"Most of the magic of PackedFunc lies in ``TVMArgs`` and ``TVMRetValue`` "
"structure. We restrict a list of possible types which can be passed. Here "
"are the common ones:"
msgstr ""
"PackedFunc的大部分魔力在于``TVMArgs`` 和 ``TVMRetValue``的结构。我们限制了一系列可能会被传输的类型。以下是常见的："

#: ../../_staging/arch/runtime.rst:98
msgid "int, float and string"
msgstr "int, float 和 string"

#: ../../_staging/arch/runtime.rst:99
msgid "PackedFunc itself"
msgstr "PackedFunc 本身"

#: ../../_staging/arch/runtime.rst:100
msgid "Module for compiled modules"
msgstr "编译模块的模块"

#: ../../_staging/arch/runtime.rst:101
msgid "DLTensor* for tensor object exchange"
msgstr "用于张量对象交换的DLTensor*"

#: ../../_staging/arch/runtime.rst:102
msgid "TVM Object to represent any object in IR"
msgstr "表示任意IR对象的TVM对象"

#: ../../_staging/arch/runtime.rst:104
msgid ""
"The restriction makes the implementation simple without the need of "
"serialization. Despite being minimum, the PackedFunc is sufficient for the "
"use-case of deep learning deployment as most functions only take DLTensor or"
" numbers."
msgstr ""
"该限制使得实现简单，无需序列化。尽管PackedFunc是最小的，但对于深度学习部署的用例来说已经足够了，因为大多数函数只接受DLTensor或数字。"

#: ../../_staging/arch/runtime.rst:108
msgid ""
"Since one PackedFunc can take another PackedFunc as an argument, we can pass"
" functions from python (as PackedFunc) to C++."
msgstr "既然一个PackedFunc可以将另一个PackedFunc当作输入，我们可以把函数（作为PackedFunc）从python传给C++。"

#: ../../_staging/arch/runtime.rst:132
msgid ""
"TVM provides a `minimum C API`_, which allows us to embed the PackedFunc "
"into any languages. Besides python, so far we supported `java`_ and "
"`javascript`_. This philosophy of embedded API is very like Lua, except that"
" we don't have a new language but use C++."
msgstr ""
"TVM提供一个允许我们将PackedFunc嵌入到任何语言的`最小 C API`_。除了python，目前我们还支持 `java`_ 和 "
"`javascript`_。这种嵌入式API的概念非常像Lua，只是我们没有用新的语言而是使用C++。"

#: ../../_staging/arch/runtime.rst:142
msgid ""
"One fun fact about PackedFunc is that we use it for both compiler and "
"deployment stack."
msgstr "一个关于PackedFunc的有趣的事实是，我们在编译器和部署堆栈都用到了它。"

#: ../../_staging/arch/runtime.rst:144
msgid ""
"All compiler pass functions of TVM are exposed to frontend as PackedFunc"
msgstr "TVM所有的编译pass函数都作为PackedFunc公开给了前端，"

#: ../../_staging/arch/runtime.rst:145
msgid "The compiled module also returns the compiled function as PackedFunc"
msgstr "编译后的模块也将作为 PackedFunc的编译后函数返回。"

#: ../../_staging/arch/runtime.rst:147
msgid ""
"To keep the runtime minimum, we isolated the IR Object support from the "
"deployment runtime. The resulting runtime takes around 200K - 600K depending"
" on how many runtime driver modules (e.g., CUDA) get included."
msgstr ""
"为了保持runtime的最小化，我们将IR对象支持与部署runtime分离。根据包含的驱动模块的数量（如CUDA），生成的runtime大概占200-600K。"

#: ../../_staging/arch/runtime.rst:149
msgid ""
"The overhead of calling into PackedFunc vs. a normal function is small, as "
"it is only saving a few values on the stack. So it is OK as long as we don't"
" wrap small functions. In summary, the PackedFunc is the universal glue in "
"TVM where we use it extensively to support our compiler and deployment."
msgstr ""
"与普通函数相比，调用PackedFunc的开销很小，因为它只在堆栈上保存了一些值。因此，只要我们不包装小函数就可以了。总之，PackedFunc是TVM中的通用粘合剂，我们在TVM中广泛使用它来支持编译器和部署。"

#: ../../_staging/arch/runtime.rst:156
msgid "Module"
msgstr "模块"

#: ../../_staging/arch/runtime.rst:158
msgid ""
"Since TVM supports multiple types of devices, we need to support different "
"type of drivers. We have to use the driver API to load the kernel, set up "
"the argument in packed format and perform kernel launch. We also need to "
"patch up the driver API so that the exposed functions are threadsafe. So we "
"often need to implement these driver glues in C++ and expose them to the "
"user. We can certainly not do it for each type of functions, so again "
"PackedFunc is our answer."
msgstr ""
"由于TVM支持多种类型的设备，我们需要支持不同类型的驱动程序。我们必须使用驱动程序API加载内核，以压缩格式设置参数并启动内核。我们还需要修补驱动程序API，以便公开的函数是线程安全的。因此，我们经常需要在C++中实现这些驱动程序粘合，并将它们公开给用户。我们当然不能对每种类型的函数都这样做，所以PackedFunc仍是我们的答案。"

#: ../../_staging/arch/runtime.rst:164
msgid ""
"TVM defines the compiled object as `Module`_. The user can get the compiled "
"function from Module as PackedFunc. The generated compiled code can "
"dynamically get function from Module in runtime. It caches the function "
"handle in the first call and reuses in subsequent calls. We use this to link"
" device code and callback into any PackedFunc(e.g., python) from generated "
"code."
msgstr ""
"TVM将编译对象定义为 "
"`模块`_。用户就可以从模块中以PackedFunc的形式得到编译后的函数。生成的编译代码可以在runtime中动态得从模块中获得函数。它在第一次调用中缓存函数句柄，并在后续调用中再次使用。我们使用它链接设备代码并用生成的代码调回到到任意PackedFunc（例如python）中。"

#: ../../_staging/arch/runtime.rst:170
msgid ""
"The ModuleNode is an abstract class that can be implemented by each type of "
"device. So far we support modules for CUDA, Metal, OpenCL and loading "
"dynamic shared libraries. This abstraction makes introduction of new device "
"easy, and we do not need to redo the host code generation for each type of "
"device."
msgstr ""
"ModuleNode "
"是一个抽象类，可以被每种设备实现。到目前为止，我们支持CUDA、Metal、OpenCL和加载动态共享库的模块。这种抽象易于引入新设备，并且我们不需要为每种类型的设备重新生成主机代码。"

#: ../../_staging/arch/runtime.rst:175
msgid "Remote Deployment"
msgstr ""

#: ../../_staging/arch/runtime.rst:177
msgid ""
"The PackedFunc and Module system also makes it easy to ship the function "
"into remote devices directly. Under the hood, we have an RPCModule that "
"serializes the arguments to do the data movement and launches the "
"computation on the remote."
msgstr ""

#: ../../_staging/arch/runtime.rst:182
msgid ""
"The RPC server itself is minimum and can be bundled into the runtime. We can"
" start a minimum TVM RPC server on iPhone/android/raspberry pi or even the "
"browser. The cross compilation on server and shipping of the module for "
"testing can be done in the same script. Checkout :ref:`tutorial-cross-"
"compilation-and-rpc` for more details."
msgstr ""

#: ../../_staging/arch/runtime.rst:187
msgid ""
"This instant feedback gives us a lot of advantages. For example, to test the"
" correctness of generated code on iPhone, we no longer have to write test-"
"cases in swift/objective-c from scratch -- We can use RPC to execute on "
"iPhone, copy the result back and do verification on the host via numpy. We "
"can also do the profiling using the same script."
msgstr ""

#: ../../_staging/arch/runtime.rst:190
msgid "TVM Object and Compiler Stack"
msgstr ""

#: ../../_staging/arch/runtime.rst:192
msgid ""
"As we mentioned earlier, we build compiler stack API on top of the "
"PackedFunc runtime system. We faced a constant changing of the compiler API "
"for the need of research. We need a new language object or IR node whenever "
"we want to test out new primitives. However, we don't want to change our API"
" from time to time. Besides that, we also want to"
msgstr ""

#: ../../_staging/arch/runtime.rst:196
msgid "be able to serialize any language object and IRs"
msgstr ""

#: ../../_staging/arch/runtime.rst:197
msgid ""
"be able to explore, print, and manipulate the IR objects in front-end "
"language to do quick prototyping."
msgstr ""

#: ../../_staging/arch/runtime.rst:199
msgid ""
"We introduced a base class, called `Object`_ to solve this problem. All the "
"language object in the compiler stack is a subclass of ``Object``. Each "
"object contains a string type_key that uniquely identifies the type of "
"object. We choose string instead of int as type key so new ``Object`` class "
"can be added in the decentralized fashion without adding the code back to "
"the central repo. To ease the speed of dispatching, we allocate an integer "
"type_index at runtime for each type_key."
msgstr ""

#: ../../_staging/arch/runtime.rst:206
msgid ""
"Since usually one ``Object`` could be referenced in multiple places in the "
"language, we use a shared_ptr to keep track of reference. We use "
"``ObjectRef`` class to represent a reference to the ``Object``. We can "
"roughly view ``ObjectRef`` class as shared_ptr to the ``Object`` container. "
"We can also define subclass ``ObjectRef`` to hold each subtypes of "
"``Object``. Each subclass of ``Object`` needs to define the VisitAttr "
"function."
msgstr ""

#: ../../_staging/arch/runtime.rst:233
msgid ""
"Each ``Object`` subclass will override this to visit its members. Here is an"
" example implementation of TensorNode."
msgstr ""

#: ../../_staging/arch/runtime.rst:258
msgid ""
"In the above examples, both ``Operation`` and ``Array<Expr>`` are ObjectRef."
" The VisitAttrs gives us a reflection API to visit each member of the "
"object. We can use this function to visit the node and serialize any "
"language object recursively. It also allows us to get members of an object "
"easily in front-end language. For example, in the following code, we "
"accessed the op field of the TensorNode."
msgstr ""

#: ../../_staging/arch/runtime.rst:273
msgid ""
"New ``Object`` can be added to C++ without changing the front-end runtime, "
"making it easy to make extensions to the compiler stack. Note that this is "
"not the fastest way to expose members to front-end language, but might be "
"one of the simplest approaches possible. We also find that it fits our "
"purposes as we mainly use python for testing and prototyping and still use "
"c++ to do the heavy lifting job."
msgstr ""

#: ../../_staging/arch/runtime.rst:279
msgid "Implementation Details"
msgstr ""

#: ../../_staging/arch/runtime.rst:281
msgid ""
"Each argument in PackedFunc contains a union value `TVMValue`_ and a type "
"code. This design allows the dynamically typed language to convert to the "
"corresponding type directly, and statically typed language to do runtime "
"type checking during conversion."
msgstr ""

#: ../../_staging/arch/runtime.rst:287
msgid "The relevant files are"
msgstr ""

#: ../../_staging/arch/runtime.rst:289
msgid "`packed_func.h`_ for C++ API"
msgstr ""

#: ../../_staging/arch/runtime.rst:290
msgid "`c_runtime_api.cc`_ for C API and how to provide callback."
msgstr ""

#: ../../_staging/arch/runtime.rst:295
msgid ""
"To support extension types, we used a registry system to register type "
"related information, like support of any in C++, see `Extension types`_ for "
"more details."
msgstr ""

#: ../../_staging/arch/runtime.rst:302
msgid "Runtime-Specific Information"
msgstr ""
