# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020 - 2021, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# 长德 司, 2021
# HLearning, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.dev1713+gbe5f05f3f\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-09-18 01:16+0000\n"
"PO-Revision-Date: 2021-09-18 07:42+0000\n"
"Last-Translator: HLearning, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/TVMChinese/teams/124815/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../_staging/dev/hybrid_script.rst:19
msgid "Hybrid Frontend Developer Guide"
msgstr "混合前端开发指南"

#: ../../_staging/dev/hybrid_script.rst:21
msgid "If you are a developer:"
msgstr "如果你是一个开发人员："

#: ../../_staging/dev/hybrid_script.rst:23
msgid ""
"1. who is trying writing some preliminary patterns that have not been "
"supported by TVM yet, maybe :ref:`hybrid-langref-label` is a better place "
"for you."
msgstr "1.当谁正在尝试编写一些尚未被TVM支持的初步模式，也许：ref:`hybrid-langref-label`对你来说是一个更好的地方。"

#: ../../_staging/dev/hybrid_script.rst:26
msgid ""
"who wants to know the implementation details of this module, you are right "
"here!"
msgstr "如果你想知道如何实现这个模块，你来对地方了！"

#: ../../_staging/dev/hybrid_script.rst:29
msgid "Features"
msgstr "特性"

#: ../../_staging/dev/hybrid_script.rst:32
msgid "Software Emulation"
msgstr "软件仿真"

#: ../../_staging/dev/hybrid_script.rst:34
msgid ""
"In software emulation, the most interesting thing is the decorator "
"``tvm.te.hybrid.script``. This decorator helps 2 things:"
msgstr "在软件仿真中，最有趣的是装饰器 ``tvm.te.hybrid.script``。这个装饰器有助于2件事："

#: ../../_staging/dev/hybrid_script.rst:37
msgid "Importing runtime variables"
msgstr "导入运行时变量"

#: ../../_staging/dev/hybrid_script.rst:39
msgid "Overloading the function according to the arguments passed"
msgstr "根据传递的参数重载函数"

#: ../../_staging/dev/hybrid_script.rst:41
msgid ""
"Correct me if I am wrong: I believe that how 1. is implemented is dangerous,"
" but I have no choice. What I did is to add those names into python dict "
"``func.__global__`` and after the call to ``func`` is done, those names will"
" be cleaned up."
msgstr ""
"如果我错了，请纠正我：我认为 1. 的实施方式是危险的，但我别无选择。我所做的是将这些名称添加到 python dict "
"``func.__global__`` 中，在调用 ``func`` 之后，这些名称将被清除。"

#: ../../_staging/dev/hybrid_script.rst:45
msgid ""
"Overload is simple: the decorator checks the arguments' types and determines"
" which function should be actually called."
msgstr "重载很简单：装饰器检查参数的类型并确定应该实际调用哪个函数。"

#: ../../_staging/dev/hybrid_script.rst:50
msgid "Backend Compilation"
msgstr "后端编译"

#: ../../_staging/dev/hybrid_script.rst:52
msgid ""
"Compilation is a large module, you can see ``python/tvm/te/hybrid/`` for "
"more details. The first stage determines the usage, or more accurately the "
"declaration of each variable and the second stage does the actual IR "
"generation."
msgstr ""
"编译是一个大模块，更多细节可以查看``python/tvm/te/hybrid/``。第一阶段确定用法，或者更准确地说是每个变量的声明，第二阶段进行实际的"
" IR 生成。"

#: ../../_staging/dev/hybrid_script.rst:58
msgid "Attributes"
msgstr "属性"

#: ../../_staging/dev/hybrid_script.rst:60
msgid ""
"So far, ONLY tensors' `shape` attribute is supported. You can see "
"``visit_Subscript`` in ``python/tvm/te/hybrid/parser.py`` for more details. "
"This is a hacky solution, I just check the attributes when subscript."
msgstr ""
"到目前为止，只支持张量的 `shape` "
"属性。您可以在“python/tvm/te/hybrid/parser.py”中查看“visit_Subscript”以了解更多详细信息。这是一个粗暴解决方案，只是在下标时检查属性。"

#: ../../_staging/dev/hybrid_script.rst:65
msgid "Loops"
msgstr "循环"

#: ../../_staging/dev/hybrid_script.rst:67
msgid ""
"In HalideIR, loops have in total 4 types: ``serial``, ``unrolled``, "
"``parallel``, and ``vectorized``."
msgstr ""
"在 HalideIR 中，循环共有 4 种类型：``serial``, ``unrolled``, ``parallel``, and "
"``vectorized``。"

#: ../../_staging/dev/hybrid_script.rst:72
msgid ""
"Unlike what that is in HalideIR, in ``loop_type(a, b)``, ``a`` is the "
"starting point and ``b`` is the trip count of iterations. Here "
"``loop_type(a, b)`` indicates ``[a, b)``. Thus, when lowering it to "
"HalideIR, we need to do ``start, extent = a, b - a``"
msgstr ""
"与 HalideIR 不同的是，在“loop_type(a, b)”中，“a”是起点，“b”是迭代次数。这里的“loop_type(a, "
"b)”表示“[a, b)”。因此，当将其降低到 HalideIR 时，我们需要执行 ``start, extent = a, b - a``"

#: ../../_staging/dev/hybrid_script.rst:79
msgid ""
"In HalideIR those are enums, they are in passive form. Here we use active "
"form to annotate loops, because they are ready to run."
msgstr ""
"在 HalideIR 中，这些是enum，它们处于passive form。这里我们使用active form来注释循环，因为它们已准备好运行。"

#: ../../_staging/dev/hybrid_script.rst:84
msgid "Variables"
msgstr "变量"

#: ../../_staging/dev/hybrid_script.rst:86
msgid ""
"Because there is no variables in ``HalideIR``, all the mutable variables "
"will be lowered to an array with size 1. It takes the first store of a "
"variable as its declaration."
msgstr "因为 ``HalideIR`` 中没有变量，所有可变变量都将被降低到一个大小为 1 的数组。它以变量的第一个存储作为其声明。"

#: ../../_staging/dev/hybrid_script.rst:90
msgid "Math Intrinsics"
msgstr "数学内在函数"

#: ../../_staging/dev/hybrid_script.rst:91
msgid ""
"So far, these math intrinsics, ``log``, ``exp``, ``sigmoid``, ``tanh``, "
"``power``, and ``popcount``, are supported. Math intrinsics will be imported"
" by the decorator. Most of the intrinsics are borrowed by library "
"implementation except ``popcount`` and ``sigmoid``. I implemented them "
"manually."
msgstr ""
"到目前为止，支持这些数学内在函数 ``log``、``exp``、``sigmoid``、``tanh``、``power`` 和 "
"``popcount``。数学内在函数将由装饰器导入。除了 ``popcount`` 和 ``sigmoid`` "
"之外，大多数内在函数都是由库实现借用的。我手动实现了它们。"

#: ../../_staging/dev/hybrid_script.rst:97
msgid "Casting"
msgstr "转换"

#: ../../_staging/dev/hybrid_script.rst:99
msgid ""
"You can cast values by using the keywords ``uint8``, ``uint16`` ``uint32``, "
"``uint64``, ``int8``, ``int16``, ``int32``, ``int64``, ``float16``, "
"``float32``, ``float64``."
msgstr ""
"您可以使用关键字  ``uint8``, ``uint16`` ``uint32``, ``uint64``, ``int8``, ``int16``,"
" ``int32``, ``int64``, ``float16``, ``float32``, ``float64``来转换数据类型。"
